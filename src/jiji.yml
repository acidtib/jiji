# Project name (required) used for organizing services
# All audit logs and deployment locks will be stored under .jiji/{project}/ on remote hosts
project: myproject

# Container engine to use (docker or podman)
engine: podman

# SSH configuration for remote connections
ssh:
  user: root
  port: 22
  # Optional: Path to SSH private key
  # key_path: ~/.ssh/id_rsa
  # Optional: SSH key passphrase
  # key_passphrase: "your-passphrase"
  # Optional: Connection timeout in seconds (default: 30)
  # connect_timeout: 30
  # Optional: Command timeout in seconds (default: 300)
  # command_timeout: 300
  # Optional: Additional SSH options
  # options:
  #   StrictHostKeyChecking: "no"
  #   UserKnownHostsFile: "/dev/null"

  # Log Level Configuration
  # Controls verbosity of SSH operation logging
  # Options: debug, info, warn, error, fatal (default: error)
  # - debug: Show all SSH operations and detailed connection info
  # - info: Show major operations and status updates
  # - warn: Show warnings and important notices
  # - error: Show only errors and failures (default)
  # - fatal: Show only critical failures
  # log_level: error

  # Multiple Private Keys Support
  # Specify multiple key files (paths are expanded automatically, ~ supported)
  # keys:
  #   - ~/.ssh/id_rsa
  #   - ~/.ssh/deploy_key
  #   - /path/to/special_key

  # Inline Key Data from Environment Variables
  # Useful for CI/CD where keys are stored as secrets
  # key_data:
  #   - SSH_PRIVATE_KEY_1
  #   - SSH_PRIVATE_KEY_2

  # Keys Only Mode - ignore ssh-agent, use only specified keys
  # Set to true to disable ssh-agent and use only keys specified above
  # keys_only: false

  # Concurrency Control
  # Limit concurrent SSH connections to prevent overwhelming servers
  # max_concurrent_starts: 30

  # Connection pool idle timeout in seconds
  # pool_idle_timeout: 900

  # DNS lookup retry attempts (with exponential backoff)
  # dns_retries: 3

  # SSH Proxy/Jump Host Configuration
  # Use either 'proxy' (ProxyJump) or 'proxy_command' (ProxyCommand), not both

  # ProxyJump - Simple bastion/jump host
  # Automatically tunnels SSH connections through the specified proxy host
  # Format: [user@]hostname[:port]
  # Examples:
  # proxy: root@bastion.example.com
  # proxy: bastion.example.com:2222
  # proxy: deploy@jump-host

  # ProxyCommand - Custom proxy command with full control
  # Executes a custom command to establish the SSH connection
  # Use %h for target hostname and %p for target port
  # Examples:
  # proxy_command: "ssh -W %h:%p user@proxy.example.com"
  # proxy_command: "ssh -W %h:%p -i ~/.ssh/bastion_key bastion.example.com"
  # proxy_command: "nc -X connect -x proxy.example.com:3128 %h %p"

  # SSH Configuration File Support
  # Load SSH configuration from ~/.ssh/config files to leverage existing SSH setups
  # This allows Jiji to inherit host-specific settings like ProxyJump, IdentityFile, etc.
  # Jiji configuration takes precedence over SSH config file settings

  # Load SSH config files:
  # config: true                    # Load default files (~/.ssh/config, /etc/ssh/ssh_config)
  # config: "~/.ssh/custom_config"  # Load specific file
  # config:                         # Load multiple files
  #   - ~/.ssh/config
  #   - ~/.ssh/work_config
  # config: false                   # Don't load config files (default)

  # When enabled, Jiji will:
  # - Parse SSH config files for host-specific settings
  # - Apply matching Host patterns (supports wildcards * and ?)
  # - Use ProxyJump/ProxyCommand from config if not set in Jiji
  # - Use IdentityFile from config if no keys specified in Jiji
  # - Apply connection timeouts and other SSH options
  # - Always prioritize Jiji configuration over SSH config file settings

# Environment-specific configuration
# env:
#   variables:
#     APP_ENV: production
#     LOG_LEVEL: info
#     DEBUG: "false"
#   # Secrets to load from environment variables
#   secrets:
#     - DATABASE_PASSWORD
#     - API_SECRET_KEY
#   # Files to load as environment variables
#   # files:
#   #   SSL_CERT: /etc/ssl/cert.pem
#   #   SSL_KEY: /etc/ssl/key.pem

# Services Configuration
# Services are the deployable units in Jiji - each service represents a containerized application
# Use service filtering during deployment to target specific services or groups
#
# Service Filtering:
# Target specific services with the --services flag:
#   jiji server bootstrap --services web-frontend
#   jiji server bootstrap --services web-frontend,api-backend
#   jiji server exec "docker ps" --services web-*
#
# Service filters support wildcards (* pattern matching):
#   --services "web-*"           # Matches: web-frontend, web-api, web-worker
#   --services "api-*,worker-*"  # Multiple wildcard patterns
#
# Combine with host filtering for precise targeting:
#   jiji server exec "systemctl status docker" --services web-* --hosts 192.168.1.100
#
services:
  # Example: Web frontend service using pre-built image
  web-frontend:
    image: nginx:latest
    hosts:
      - 192.168.1.100
      - 192.168.1.101
    ports:
      - "127.0.0.1:8080:80"
    # Volumes: Docker/Podman named volumes or host paths
    volumes:
      - "web_storage:/opt/uploads"
      - "./data:/opt/extra_data:ro"
    # Files: Upload from local repo to host .jiji/{project}/files/ before mounting
    # String format: local:remote[:options] where options can be ro, z, or Z
    files:
      - "nginx.conf:/etc/nginx/nginx.conf:ro"
    # Or use hash format for custom permissions and ownership:
    # files:
    #   - local: config/secret.key
    #     remote: /etc/app/secret.key
    #     mode: "0600"
    #     owner: "nginx:nginx"
    #     options: "ro"
    # Directories: Created on host .jiji/{project}/directories/ before mounting
    # String format: local:remote[:options] where options can be ro, z, or Z
    directories:
      - "html:/usr/share/nginx/html:ro"
    # Or use hash format for custom permissions and ownership:
    # directories:
    #   - local: logs
    #     remote: /var/log/nginx
    #     mode: "0755"
    #     owner: "nginx:nginx"
    #     options: "z"
    environment:
      NGINX_WORKER_PROCESSES: auto
      NGINX_WORKER_CONNECTIONS: "1024"
    # Optional: Proxy configuration for automatic SSL and routing
    # proxy:
    #   ssl: false
    #   host: web.myproject.example.com
    #   healthcheck:
    #     path: /health
    #     interval: 10s

  # Example: API service using custom build
  # api-backend:
  #   build:
  #     context: ./api
  #     dockerfile: Dockerfile
  #     args:
  #       NODE_ENV: production
  #       API_VERSION: "2.1.0"
  #   hosts:
  #     - 192.168.1.100
  #     - 192.168.1.102
  #   ports:
  #     - "3000:3000"
  #   environment:
  #     NODE_ENV: production
  #     DATABASE_URL: "postgresql://user:pass@192.168.1.103:5432/myapp"
  #     REDIS_URL: "redis://192.168.1.104:6379"
  #   command: ["node", "dist/server.js"]
  #   volumes:
  #     - "/app/logs:/var/log/app"
  #   proxy:
  #     ssl: true
  #     host: api.myproject.example.com
  #     healthcheck:
  #       path: /api/health
  #       interval: 15s

  # Example: Worker service for background jobs
  # worker-queue:
  #   build:
  #     context: ./worker
  #     dockerfile: Dockerfile
  #   hosts:
  #     - 192.168.1.103
  #   environment:
  #     QUEUE_URL: "redis://192.168.1.104:6379"
  #     WORKER_CONCURRENCY: "4"
  #   command: ["npm", "run", "worker"]
  #   volumes:
  #     - "/app/worker-data:/data"

  # Example: Database service
  # database:
  #   image: postgres:15-alpine
  #   hosts:
  #     - 192.168.1.103
  #   ports:
  #     - "127.0.0.1:5432:5432"
  #   environment:
  #     POSTGRES_DB: myapp
  #     POSTGRES_USER: appuser
  #     POSTGRES_PASSWORD: securepassword
  #   volumes:
  #     - "/data/postgres:/var/lib/postgresql/data"

  # Example: Cache service
  # cache:
  #   image: redis:7-alpine
  #   hosts:
  #     - 192.168.1.104
  #   ports:
  #     - "127.0.0.1:6379:6379"
  #   volumes:
  #     - "/data/redis:/data"
  #   command: ["redis-server", "--appendonly", "yes"]

# Service Deployment Filtering Examples:
# =====================================
# Deploy specific services:           jiji deploy --services web-frontend,api-backend
# Deploy by pattern:                  jiji deploy --patterns "web-*,*-backend"
# Deploy build-only services:         jiji deploy --build-only
# Deploy image-only services:         jiji deploy --image-only
# Deploy to specific hosts:           jiji deploy --target-hosts 192.168.1.100,192.168.1.101
# Exclude services:                   jiji deploy --exclude worker-queue,cache
# Combine filters:                    jiji deploy --patterns "web-*" --exclude web-admin --target-hosts 192.168.1.100
