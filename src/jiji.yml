# Jiji Deployment Configuration Template
# =====================================

# Project name (required) used for organizing services
# All audit logs and deployment locks will be stored under .jiji/{project}/ on remote hosts
project: myproject

# Container engine to use (docker or podman)
engine: podman

# SSH configuration for remote connections
ssh:
  user: root
  port: 22
  # Optional: Path to SSH private key
  # key_path: ~/.ssh/id_rsa
  # Optional: SSH key passphrase
  # key_passphrase: "your-passphrase"
  # Optional: Connection timeout in seconds (default: 30)
  # connect_timeout: 30
  # Optional: Command timeout in seconds (default: 300)
  # command_timeout: 300
  # Optional: Additional SSH options
  # options:
  #   StrictHostKeyChecking: "no"
  #   UserKnownHostsFile: "/dev/null"

  # Multiple Private Keys Support
  # Specify multiple key files (paths are expanded automatically, ~ supported)
  # keys:
  #   - ~/.ssh/id_rsa
  #   - ~/.ssh/deploy_key
  #   - /path/to/special_key

  # Inline Key Data from Environment Variables
  # Useful for CI/CD where keys are stored as secrets
  # key_data:
  #   - SSH_PRIVATE_KEY_1
  #   - SSH_PRIVATE_KEY_2

  # Keys Only Mode - ignore ssh-agent, use only specified keys
  # Set to true to disable ssh-agent and use only keys specified above
  # keys_only: false

  # SSH Proxy/Jump Host Configuration
  # Use either 'proxy' (ProxyJump) or 'proxy_command' (ProxyCommand), not both

  # ProxyJump - Simple bastion/jump host
  # Automatically tunnels SSH connections through the specified proxy host
  # Format: [user@]hostname[:port]
  # Examples:
  # proxy: root@bastion.example.com
  # proxy: bastion.example.com:2222
  # proxy: deploy@jump-host

  # ProxyCommand - Custom proxy command with full control
  # Executes a custom command to establish the SSH connection
  # Use %h for target hostname and %p for target port
  # Examples:
  # proxy_command: "ssh -W %h:%p user@proxy.example.com"
  # proxy_command: "ssh -W %h:%p -i ~/.ssh/bastion_key bastion.example.com"
  # proxy_command: "nc -X connect -x proxy.example.com:3128 %h %p"

# Services configuration
services:
  # Example web service using a pre-built image
  web:
    image: nginx:latest
    hosts:
      - 192.168.1.100
      - 192.168.1.101
    ports:
      - "127.0.0.1:3000:80"
    volumes:
      - "/etc/nginx/nginx.conf:/etc/nginx/nginx.conf:ro"
      - "/var/www/html:/usr/share/nginx/html:ro"
    # Optional: Proxy configuration
    # Enables automatic SSL termination and routing
    # proxy:
    #   ssl: false
    #   host: myproject.example.com
    #   healthcheck:
    #     path: /health
    #     interval: 10s

  # Example application service using build configuration
  # app:
  #   build:
  #     context: ./app
  #     dockerfile: Dockerfile
  #     args:
  #       NODE_ENV: production
  #       BUILD_VERSION: "1.0.0"
  #   hosts:
  #     - 192.168.1.100
  #   ports:
  #     - "3000:3000"
  #   environment:
  #     NODE_ENV: production
  #     DATABASE_URL: "postgresql://user:pass@db:5432/myapp"
  #   command: ["node", "server.js"]
  #   volumes:
  #     - "/app/logs:/var/log/app"
  #   proxy:
  #     ssl: true
  #     host: app.example.com
  #     healthcheck:
  #       path: /up
  #       interval: 10s

  # Example database service
  # database:
  #   image: postgres:15
  #   hosts:
  #     - 192.168.1.102
  #   ports:
  #     - "5432:5432"
  #   environment:
  #     POSTGRES_DB: myapp
  #     POSTGRES_USER: dbuser
  #     POSTGRES_PASSWORD: dbpass
  #   volumes:
  #     - "/data/postgres:/var/lib/postgresql/data"

# Optional: Environment-specific configuration
# env:
#   variables:
#     APP_ENV: production
#     LOG_LEVEL: info
#     DEBUG: "false"
#   # Secrets to load from environment variables
#   secrets:
#     - DATABASE_PASSWORD
#     - API_SECRET_KEY
#   # Files to load as environment variables
#   # files:
#   #   SSL_CERT: /etc/ssl/cert.pem
#   #   SSL_KEY: /etc/ssl/key.pem
